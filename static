
static 可以修饰成员变量，可以修饰成员方法
static 修饰成员变量的分类：
        1.静态成员变量：有 static 修饰，属于类，与类一起加载，内存中只存在一份，可以被共享访问
                        如果想要被共享，只需要一份使用，就可以使用 static
                        规则：建议用类名访问，即类名.静态成员变量
                              同一个类中，访问静态成员可以省略类名不写
                              理论上也可以这样访问，即对象名.静态成员变量（不推荐）
        2.实例成员变量：无 static 修饰，属于对象，每个对象中都存在一份示例成员变量，比如： name.age
                        每个对象都有这些信息，而且信息还不同时，定义成实例成员变量
                        规则：只能用，即对象名.实例成员变量

static 应用知识：
        1.工具类：里面都是静态方法，为了完成一个共用功能
                  好处：一次编写，处处可调。提高代码的复用，提高开发的效率
                  建议把工具类的构造器私有化，因为工具类无需对外创建对象，它的方法都是静态方法，直接用类名访问即可
        2.代码块：类的五大部分（成员变量，成员方法，构造器，代码块，内部块）
                  分类：静态代码块：格式：static{}
                                    特点：属于类，与类一起加载，自动触发一次
                                    作用：可以用于在程序启动时，进行静态资源的初始化操作
                        实例代码块（几乎不用）：格式{}
                                                特点：属于对象，每次调用构造器对象前都会执行一次，再执行构造器
                                                作用：可以用于初始化实例资源，但是会把所有资源初始化为同一个


单例：单例是一种设计模式，是为了解决某个问题
      单例解决：保证一个类对外只能产生一个对象
      实现单例：
        1.饿汉单例：特点：拿对象时，对象已经存在
                    实现步骤：1.构造器私有化
                              2.定义静态成员变量存储一个对象
                              3.代码实现：public class Single{
                                             //这个对象只能是一个，所以定义静态成员变量记住
                                             public static Single instance = new Single();
                                             //必须把构造器私有化
                                             private Single(){
                                             }
                                         }

        2.懒汉单例：特点：要拿对象的时侯，才开始创建一个对象
                    实现步骤：1.构造器私有
                              2.定义静态成员变量，暂时不存储对象
                              3.代码：public class Lazy{
                                         //只有一份，只加载一次
                                         private static Lazy instance;
                                         //提供一个方法，对外返回单例对象
                                         public static Lazy getinstance(){
                                             if(instance == null)
                                                 instance = new Lazy();
                                             return instance;
                                         }
                                         //私有化构造器
                                         private Lazy(){
                                         }
                                      }
