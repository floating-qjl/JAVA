

泛型概述：
        泛型是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。

泛型的格式：<数据类型>;
        注意:泛型只能支持引用数据类型。
        集合体系的全部接口和实现类都是支持泛型的使用的。

泛型的好处：
        统一数据类型。
        把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。


泛型可以在很多地方进行定义：
        类后面             泛型类
        方法申明上         泛型方法
        接口后面           泛型接口




自定义泛型类：
        定义类时同时定义了泛型的类就是泛型类。
        泛型类的格式:修饰符 class 类名<泛型变量>{ }
范例： public class MyArrayList<T>{ }
此处泛型变量T可以随便写为任意标识，常见的如E、T、K、v等。
作用:编译阶段可以指定数据类型，类似于集合的作用。


自定义泛型方法：
        定义方法时同时定义了泛型的方法就是泛型方法。
        泛型方法的格式:修饰符<泛型变量>方法返回值方法名称(形参列表)报

例如：
        public <T> void show(T t){ }
        作用:方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。
        public static <T> void printArray(T[] arr){
        if(arr != null){
        stringBuilder sb = new stringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
          sb.append(arr[i]).append(i == arr.length - 1 ? "" : "，");
        }
        sb.append("]");
        system.out.println(sb);
        }else {
        system.out.println(arr)；
        }

泛型方法的核心思想：
        把出现泛型变量的地方全部替换成传输的真实数据类型
泛型方法的作用：
        方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性



自定义泛型接口：
        使用了泛型定义的接口就是泛型接口。
        泛型接口的格式:修饰符interface接口名称<泛型变量>(
        public interface Data<E>{}
        作用：泛型接可以让实现类选择当前功能需要操作的数据类型

泛型接口的原理：
        实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。

泛型接口的作用：
        泛型接口可以约束实现类，实现类可以在实现接口的时候传入自己操作的数据类型这样重写的方法都将是针对于该类型的操作。

泛型通配符：
        通配符:?
        ﹖可以在“使用泛型”的时候代表一切类型。
        ET KV是在定义泛型的时候使用的。

注意:虽然BMW和BENZ都继承了Car但是ArrayList<BMW>和ArrayList<BENZ>与ArrayList<Car>没有关系的! !
public static void go(ArrayList<?> cars){
}

泛型的上下限：
        ? extends Car: ?必须是Car或者其子类泛型上限
        ? super car : ?必须是Car或者其父类_泛型下限
以防止无关的类加入到一切类型的集合中


