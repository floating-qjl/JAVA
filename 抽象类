
抽象类：
在java中 abstract 是抽象的意思，可以修饰类、成员方法
abstract 修饰类，这个类就是抽象类；修饰方法，这个方法就是抽象方法
修饰符 abstract class 类名{
    修饰符 abstract 返回值类型 方法名称（形参列表）
}
例如：
public abstract class Animal{
    public abstract void run();
}

注意事项：
抽象方法只有方法签名，不能声明方法体
一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错

抽象的使用场景：
抽象类可以理解成不完整的设计图，一般作为父类，让子类来继承
当父类知道子类一定要完成某些行为，但是每个子类该行为的实现又不同，
于是该父类就把该行为定义成抽象方法的形式，具体实现交给子类去完成，此时这个类就可以声明称抽象类
抽象方法没有方法体，即{ }

特征和注意事项：
类有的成员（成员变量、方法、构造器）抽象类都具备
抽象类中不一定有抽象的方法，有抽象方法的类一定是抽象类
一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类
不能使用 abstract 修饰变量、代码块、构造器
最重要的特征：
        得到了抽象方法，失去了创建对象的能力（有得有失） --- 方法连方法体都没有，假设可以创建，那程序肯定也不能运行
        如果抽象类里面没有抽象方法，那也不能创建对象，以防止未来可能创建抽象方法

final 和 abstract 是互斥关系：
abstract 定义的抽象类作为模板让子类继承，否则没有意义，final定义的类不能被继承
抽象方法定义通用功能让子类重写，final定义的方法子类不能重写







模板方法模式：
使用场景说明：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候
实现步骤：把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码
          模板方法中不能决定的功能定义成抽象方法让具体子类去实现
模板方法可以使用 final 进行修饰，因为模板方法是给子类直接使用的，不是让子类重写的
，一旦子类重写了模板方法，则模板方法就失效了，因此加上 final，使其不能被重写，这样更专业、安全

提高了代码的复用性
模板方法已经定义了通用结构，模板方法不能确定的部分定义成抽象方法，交给子类实现，因此
使用者只需要关心自己需要实现的功能即可
