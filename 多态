

多态：
同类型的对象，执行同一个行为，会表现出不同的行为特征
常见形式：
父类类型 对象名称 = new 子类构造器;
接口 对象名称 = new 实现类构造器;

多态中成员访问特点：
方法调用：编译看左边，运行看右边（使用子类的方法）
变量调用：编译看左边，运行也看左边（使用父类的变量）

优势：
1.在多态形式下，右边对象可以实现解耦合，便于扩展和维护
Animal a = new Dog();
a.run;//后续业务行为随对象而变，后续代码无需修改
2.定义方法时，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利

多态下会产生一个问题：
多态下不能使用子类的独有功能（方法）


自动类型转换（从子到父）：子类对象赋值给父类类型的变量指向
强制类型转换（从父到子）：
此时必须进行强制类型转换，即 子类 对象变量 = （子类）父类类型的变量
作用：可以解决多态下的劣势，可以实现调用子类独有的功能
注意：如果转型后的类型和对象真实类型不是同一种类型，那么在转换的时候就会出现ClassCastException
例如：
Animal t = new Tortoise();
Dog d = (Dog)t;//出现异常
有继承或实现关系，在编译阶段就算强制转换不符合实际也是不会报错的，但是运行会出问题
java 建议强制转换前使用 instanceof 判断当前对象的真实类型，再进行强制类型转换
格式：
变量名 instanceof 真实类型
判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其 子类 类型，是则返回 true，反之为 false
例如：
Animal t = new Tortoise();
if(t instanceof Tortoise){
    Tortoise d = (Tortoise)t;
    //再执行独有功能
}
else if(t instanceof Dog){
    Dog d = (Dog)t;
    //执行独有功能
}
在传参传过来是父类类型，不能确定 其子类 类型的时候，这种判断就尤为重要

